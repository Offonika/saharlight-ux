import datetime
import logging
from collections.abc import Awaitable, Callable, Coroutine
from typing import TypeVar, cast

from telegram import Update
from telegram.ext import (
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from services.api.app.diabetes.services.db import (
    Profile,
    SessionLocal,
)

try:
    from services.api.app.diabetes.services.db import run_db as _run_db
except Exception:  # pragma: no cover - optional db runner
    run_db: Callable[..., Awaitable[object]] | None = None
else:
    run_db = cast(Callable[..., Awaitable[object]], _run_db)
from services.api.app.diabetes.services.repository import commit
from services.api.app.diabetes.utils.functions import (
    PatientProfile,
    _safe_float,
    calc_bolus,
    smart_input,
)
from services.api.app.diabetes.utils.constants import XE_GRAMS
from services.api.app.diabetes.utils.ui import (
    confirm_keyboard,
    dose_keyboard,
    menu_keyboard,
)

from .common_handlers import menu_command
from .profile import profile_view
from services.api.app.diabetes.gpt_command_parser import parse_command
from .alert_handlers import check_alert
from .reporting_handlers import history_view, report_request, send_report
from . import EntryData, UserData

logger = logging.getLogger(__name__)

T = TypeVar("T")

DOSE_METHOD, DOSE_XE, DOSE_CARBS, DOSE_SUGAR = range(3, 7)
END: int = ConversationHandler.END


async def dose_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Entry point for dose calculation conversation."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    user_data.pop("pending_entry", None)
    user_data.pop("edit_id", None)
    user_data.pop("dose_method", None)
    await message.reply_text(
        "üíâ –ö–∞–∫ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–æ–∑—É? –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥:",
        reply_markup=dose_keyboard,
    )
    return DOSE_METHOD


async def dose_method_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle method selection for dose calculation."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    text = message.text
    if text is None:
        return END
    text = text.lower()
    if "–Ω–∞–∑–∞–¥" in text:
        return await dose_cancel(update, context)
    if "—É–≥–ª–µ–≤" in text:
        user_data["dose_method"] = "carbs"
        await message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–≥–ª–µ–≤–æ–¥–æ–≤ (–≥).")
        return DOSE_CARBS
    if "xe" in text or "—Ö–µ" in text:
        user_data["dose_method"] = "xe"
        await message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –•–ï.")
        return DOSE_XE
    await message.reply_text(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥: –•–ï –∏–ª–∏ —É–≥–ª–µ–≤–æ–¥—ã.",
        reply_markup=dose_keyboard,
    )
    return DOSE_METHOD


async def dose_xe(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Capture XE amount from user."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    text = message.text
    if text is None:
        return END
    user = update.effective_user
    if user is None:
        return END
    xe = _safe_float(text)
    if xe is None:
        await message.reply_text("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –•–ï.")
        return DOSE_XE
    if xe < 0:
        await message.reply_text("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –•–ï –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.")
        return DOSE_XE
    entry: EntryData = {
        "telegram_id": user.id,
        "event_time": datetime.datetime.now(datetime.timezone.utc),
        "xe": xe,
    }
    user_data["pending_entry"] = entry
    await message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—É—â–∏–π —Å–∞—Ö–∞—Ä (–º–º–æ–ª—å/–ª).")
    return DOSE_SUGAR


async def dose_carbs(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Capture carbohydrates in grams."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    text = message.text
    if text is None:
        return END
    user = update.effective_user
    if user is None:
        return END
    carbs = _safe_float(text)
    if carbs is None:
        await message.reply_text("–í–≤–µ–¥–∏—Ç–µ —É–≥–ª–µ–≤–æ–¥—ã —á–∏—Å–ª–æ–º –≤ –≥—Ä–∞–º–º–∞—Ö.")
        return DOSE_CARBS
    if carbs < 0:
        await message.reply_text("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–≥–ª–µ–≤–æ–¥–æ–≤ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.")
        return DOSE_CARBS
    entry: EntryData = {
        "telegram_id": user.id,
        "event_time": datetime.datetime.now(datetime.timezone.utc),
        "carbs_g": carbs,
    }
    user_data["pending_entry"] = entry
    await message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—É—â–∏–π —Å–∞—Ö–∞—Ä (–º–º–æ–ª—å/–ª).")
    return DOSE_SUGAR


async def dose_sugar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Finalize dose calculation after receiving sugar level."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    text = message.text
    if text is None:
        return END
    user = update.effective_user
    if user is None:
        return END
    sugar = _safe_float(text)
    if sugar is None:
        await message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å–∞—Ö–∞—Ä —á–∏—Å–ª–æ–º –≤ –º–º–æ–ª—å/–ª.")
        return DOSE_SUGAR
    if sugar < 0:
        await message.reply_text("–°–∞—Ö–∞—Ä –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.")
        return DOSE_SUGAR

    entry = cast(EntryData, user_data.get("pending_entry", {}))
    entry["sugar_before"] = sugar
    xe = entry.get("xe")
    carbs_g = entry.get("carbs_g")
    if carbs_g is None and xe is None:
        await message.reply_text(
            "–ù–µ —É–∫–∞–∑–∞–Ω—ã —É–≥–ª–µ–≤–æ–¥—ã –∏–ª–∏ –•–ï. –†–∞—Å—á—ë—Ç –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.",
            reply_markup=menu_keyboard,
        )
        user_data.pop("pending_entry", None)
        return END
    if carbs_g is None and xe is not None:
        carbs_g = XE_GRAMS * xe
        entry["carbs_g"] = carbs_g

    user_id = user.id
    if run_db is None:
        with SessionLocal() as session:
            profile = session.get(Profile, user_id)
    else:
        profile = await run_db(
            lambda s: s.get(Profile, user_id),
            sessionmaker=SessionLocal,
        )

    if (
        profile is None
        or profile.icr is None
        or profile.cf is None
        or profile.target_bg is None
    ):
        await message.reply_text(
            "–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —á–µ—Ä–µ–∑ /profile.",
            reply_markup=menu_keyboard,
        )
        user_data.pop("pending_entry", None)
        return END

    patient = PatientProfile(
        icr=profile.icr,
        cf=profile.cf,
        target_bg=profile.target_bg,
    )
    dose = calc_bolus(carbs_g, sugar, patient)
    entry["dose"] = dose

    user_data["pending_entry"] = entry

    xe_info = f", –•–ï: {xe}" if xe is not None else ""
    await message.reply_text(
        text=(
            f"üíâ –†–∞—Å—á—ë—Ç –∑–∞–≤–µ—Ä—à—ë–Ω:\n"
            f"‚Ä¢ –£–≥–ª–µ–≤–æ–¥—ã: {carbs_g} –≥{xe_info}\n"
            f"‚Ä¢ –°–∞—Ö–∞—Ä: {sugar} –º–º–æ–ª—å/–ª\n"
            f"‚Ä¢ –í–∞—à–∞ –¥–æ–∑–∞: {dose} –ï–¥\n\n"
            "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç—Ç–æ –≤ –¥–Ω–µ–≤–Ω–∏–∫?"
        ),
        reply_markup=confirm_keyboard(),
    )
    return END


async def dose_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancel dose calculation conversation."""
    user_data_raw = context.user_data
    if user_data_raw is None:
        return END
    user_data = cast(UserData, user_data_raw)
    message = update.message
    if message is None:
        return END
    await message.reply_text("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=menu_keyboard)
    user_data.pop("pending_entry", None)
    user_data.pop("dose_method", None)
    chat_data = getattr(context, "chat_data", None)
    if chat_data is not None:
        chat_data.pop("sugar_active", None)
    return END


def _cancel_then(
    handler: Callable[
        [Update, ContextTypes.DEFAULT_TYPE], Coroutine[object, object, T]
    ],
) -> Callable[[Update, ContextTypes.DEFAULT_TYPE], Coroutine[object, object, T]]:
    """Return a wrapper calling ``dose_cancel`` before ``handler``."""

    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE) -> T:
        await dose_cancel(update, context)
        return await handler(update, context)

    return wrapped


# Import additional handlers after defining dose_cancel to avoid circular imports
from .sugar_handlers import (
    SUGAR_VAL,
    sugar_start,
    sugar_val,
    sugar_conv,
    prompt_sugar,
)  # noqa: E402
from .photo_handlers import (  # noqa: E402
    PHOTO_SUGAR,
    WAITING_GPT_FLAG,
    doc_handler,
    photo_handler,
    photo_prompt,
    prompt_photo,
)
from . import gpt_handlers as _gpt_handlers  # noqa: E402


async def freeform_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    return await _gpt_handlers.freeform_handler(
        update,
        context,
        SessionLocal=SessionLocal,
        commit=commit,
        check_alert=check_alert,
        menu_keyboard=menu_keyboard,
        smart_input=smart_input,
        parse_command=parse_command,
        send_report=send_report,
    )


chat_with_gpt = _gpt_handlers.chat_with_gpt


dose_conv = ConversationHandler(
    entry_points=[
        CommandHandler("dose", dose_start),
        MessageHandler(filters.Regex("^üíâ –î–æ–∑–∞ –∏–Ω—Å—É–ª–∏–Ω–∞$"), dose_start),
    ],
    states={
        DOSE_METHOD: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, dose_method_choice)
        ],
        DOSE_XE: [MessageHandler(filters.Regex(r"^-?\d+(?:[.,]\d+)?$"), dose_xe)],
        DOSE_CARBS: [MessageHandler(filters.Regex(r"^-?\d+(?:[.,]\d+)?$"), dose_carbs)],
        DOSE_SUGAR: [MessageHandler(filters.Regex(r"^-?\d+(?:[.,]\d+)?$"), dose_sugar)],
    },
    fallbacks=[
        MessageHandler(filters.Regex("^‚Ü©Ô∏è –ù–∞–∑–∞–¥$"), dose_cancel),
        CommandHandler("menu", cast(object, _cancel_then(menu_command))),
        MessageHandler(
            filters.Regex("^üì∑ –§–æ—Ç–æ –µ–¥—ã$"), cast(object, _cancel_then(photo_prompt))
        ),
        MessageHandler(
            filters.Regex("^ü©∏ –£—Ä–æ–≤–µ–Ω—å —Å–∞—Ö–∞—Ä–∞$"),
            cast(object, _cancel_then(sugar_start)),
        ),
        MessageHandler(
            filters.Regex("^üìä –ò—Å—Ç–æ—Ä–∏—è$"), cast(object, _cancel_then(history_view))
        ),
        MessageHandler(
            filters.Regex("^üìà –û—Ç—á—ë—Ç$"), cast(object, _cancel_then(report_request))
        ),
        MessageHandler(
            filters.Regex("^üìÑ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å$"), cast(object, _cancel_then(profile_view))
        ),
    ],
)

prompt_dose = dose_start

__all__ = [
    "SessionLocal",
    "DOSE_METHOD",
    "DOSE_XE",
    "DOSE_CARBS",
    "DOSE_SUGAR",
    "END",
    "dose_start",
    "dose_method_choice",
    "dose_xe",
    "dose_carbs",
    "dose_sugar",
    "dose_cancel",
    "_cancel_then",
    "dose_conv",
    "prompt_dose",
    "commit",
    "parse_command",
    "smart_input",
    "send_report",
    # re-exported handlers
    "photo_prompt",
    "photo_handler",
    "doc_handler",
    "prompt_photo",
    "sugar_start",
    "sugar_val",
    "sugar_conv",
    "prompt_sugar",
    "freeform_handler",
    "chat_with_gpt",
    "PHOTO_SUGAR",
    "SUGAR_VAL",
    "WAITING_GPT_FLAG",
]
