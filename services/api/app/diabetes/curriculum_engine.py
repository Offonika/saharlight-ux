"""Learning curriculum engine for diabetes lessons."""

from __future__ import annotations

import logging

from sqlalchemy.orm import Session

from .learning_prompts import (
    SYSTEM_TUTOR_RU,
    build_explain_step,
    build_feedback,
    disclaimer,
)
from .llm_router import LLMTask
from .models_learning import Lesson, LessonProgress, LessonStep, QuizQuestion
from .services import db, gpt_client
from .services.repository import commit

logger = logging.getLogger(__name__)


async def start_lesson(user_id: int, lesson_slug: str) -> LessonProgress:
    """Start or reset a lesson for a user and return progress."""

    def _start(session: Session) -> LessonProgress:
        lesson = session.query(Lesson).filter_by(slug=lesson_slug).one()
        progress = (
            session.query(LessonProgress)
            .filter_by(user_id=user_id, lesson_id=lesson.id)
            .one_or_none()
        )
        if progress is None:
            progress = LessonProgress(
                user_id=user_id,
                lesson_id=lesson.id,
                current_step=0,
                current_question=0,
                completed=False,
                quiz_score=None,
            )
            session.add(progress)
        else:
            progress.current_step = 0
            progress.current_question = 0
            progress.completed = False
            progress.quiz_score = None
        commit(session)
        session.refresh(progress)
        return progress

    return await db.run_db(_start)


async def next_step(user_id: int, lesson_id: int) -> str | None:
    """Advance the lesson and return either step text or quiz question.

    Parameters
    ----------
    user_id:
        Telegram identifier of the user.
    lesson_id:
        Identifier of the lesson to continue.

    Returns
    -------
    str | None
        Text generated by LLM for the next step, a quiz question with options,
        or ``None`` when the lesson is fully complete.
    """

    def _advance(
        session: Session,
    ) -> tuple[str | None, str | None, bool, bool]:
        progress = (
            session.query(LessonProgress)
            .filter_by(user_id=user_id, lesson_id=lesson_id)
            .one()
        )
        steps = (
            session.query(LessonStep)
            .filter_by(lesson_id=lesson_id)
            .order_by(LessonStep.step_order)
            .all()
        )
        if progress.current_step < len(steps):
            step = steps[progress.current_step]
            is_first_step = progress.current_step == 0
            progress.current_step += 1
            commit(session)
            return step.content, None, is_first_step, False
        questions = (
            session.query(QuizQuestion)
            .filter_by(lesson_id=lesson_id)
            .order_by(QuizQuestion.id)
            .all()
        )
        if progress.current_question < len(questions):
            q = questions[progress.current_question]
            is_first_question = progress.current_question == 0
            opts = "\n".join(
                f"{idx}. {opt}" for idx, opt in enumerate(q.options)
            )
            return None, f"{q.question}\n{opts}", False, is_first_question
        return None, None, False, False

    step_content, question_text, first_step, first_question = await db.run_db(
        _advance
    )
    if step_content is not None:
        completion = await gpt_client.create_learning_chat_completion(
            task=LLMTask.EXPLAIN_STEP,
            messages=[
                {"role": "system", "content": SYSTEM_TUTOR_RU},
                {"role": "user", "content": build_explain_step(step_content)},
            ],
        )
        reply = completion.choices[0].message.content or ""
        if first_step:
            return f"{disclaimer()} {reply}".strip()
        return reply
    if question_text is not None:
        if first_question:
            return f"{disclaimer()} {question_text}".strip()
        return question_text
    return None


async def check_answer(
    user_id: int, lesson_id: int, answer_index: int
) -> tuple[bool, str]:
    """Check user's answer to current quiz question and return feedback."""

    def _check(session: Session) -> tuple[bool, str]:
        progress = (
            session.query(LessonProgress)
            .filter_by(user_id=user_id, lesson_id=lesson_id)
            .one()
        )
        questions = (
            session.query(QuizQuestion)
            .filter_by(lesson_id=lesson_id)
            .order_by(QuizQuestion.id)
            .all()
        )
        question = questions[progress.current_question]
        correct = answer_index == question.correct_option
        explanation = question.options[question.correct_option]
        score = progress.quiz_score or 0
        if correct:
            score += 1
        progress.quiz_score = score
        progress.current_question += 1
        if progress.current_question >= len(questions):
            progress.completed = True
            progress.quiz_score = int(100 * score / len(questions))
        commit(session)
        return correct, explanation

    correct, explanation = await db.run_db(_check)
    completion = await gpt_client.create_learning_chat_completion(
        task=LLMTask.QUIZ_CHECK,
        messages=[
            {"role": "system", "content": SYSTEM_TUTOR_RU},
            {"role": "user", "content": build_feedback(correct, explanation)},
        ],
    )
    message = completion.choices[0].message.content or ""
    return correct, message


__all__ = ["start_lesson", "next_step", "check_answer"]

