# coding: utf-8

"""
Diabetes Assistant API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import io
import json
import re
import ssl
from collections.abc import Iterable, Mapping

import urllib3

from diabetes_sdk.configuration import Configuration
from diabetes_sdk.exceptions import ApiException, ApiValueError

SUPPORTED_SOCKS_PROXIES = {"socks5", "socks5h", "socks4", "socks4a"}
RESTResponseType = urllib3.HTTPResponse


def is_socks_proxy_url(url: str | None) -> bool:
    if url is None:
        return False
    split_section = url.split("://")
    if len(split_section) < 2:
        return False
    else:
        return split_section[0].lower() in SUPPORTED_SOCKS_PROXIES


class RESTResponse(io.IOBase):

    def __init__(self, resp: RESTResponseType) -> None:
        self.response: RESTResponseType = resp
        self.status: int = resp.status
        self.reason: str = resp.reason
        self.data: bytes | None = None

    def read(self) -> bytes:
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self) -> Mapping[str, str]:
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name: str, default: str | None = None) -> str | None:
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration: Configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        pool_args: dict[str, object] = {
            "cert_reqs": cert_reqs,
            "ca_certs": configuration.ssl_ca_cert,
            "cert_file": configuration.cert_file,
            "key_file": configuration.key_file,
            "ca_cert_data": configuration.ca_cert_data,
        }
        if configuration.assert_hostname is not None:
            pool_args["assert_hostname"] = configuration.assert_hostname

        if configuration.retries is not None:
            pool_args["retries"] = configuration.retries

        if configuration.tls_server_name:
            pool_args["server_hostname"] = configuration.tls_server_name

        if configuration.socket_options is not None:
            pool_args["socket_options"] = configuration.socket_options

        if configuration.connection_pool_maxsize is not None:
            pool_args["maxsize"] = configuration.connection_pool_maxsize

        # https pool manager
        self.pool_manager: urllib3.PoolManager

        if configuration.proxy:
            if is_socks_proxy_url(configuration.proxy):
                from urllib3.contrib.socks import SOCKSProxyManager

                pool_args["proxy_url"] = configuration.proxy
                pool_args["headers"] = configuration.proxy_headers
                self.pool_manager = SOCKSProxyManager(**pool_args)
            else:
                pool_args["proxy_url"] = configuration.proxy
                pool_args["proxy_headers"] = configuration.proxy_headers
                self.pool_manager = urllib3.ProxyManager(**pool_args)
        else:
            self.pool_manager = urllib3.PoolManager(**pool_args)

    def request(
        self,
        method: str,
        url: str,
        headers: dict[str, str] | None = None,
        body: object | None = None,
        post_params: Mapping[str, object] | Iterable[tuple[str, object]] | None = None,
        _request_timeout: float | tuple[float, float] | None = None,
    ) -> RESTResponse:
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request parameters for
                            ``application/x-www-form-urlencoded`` or
                            ``multipart/form-data``. Accepts either a
                            mapping object (for example ``dict``) or any
                            iterable of ``(key, value)`` pairs. Each item
                            **must** contain exactly two elements. Values
                            that are themselves mappings or non-string
                            iterables are JSON serialized before being sent.

                            Examples::

                                post_params = {"a": 1, "meta": {"b": 2}}
                                post_params = [("a", 1), ("meta", {"b": 2})]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        # Normalize and validate HTTP method
        method = method.upper()
        if method not in {"GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"}:
            raise ApiValueError(f"{method} is not a supported HTTP method")

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        if post_params is None:
            post_params = {}
        if headers is None:
            headers = {}

        timeout: urllib3.Timeout | None = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0], read=_request_timeout[1]
                )

        try:
            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
            if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:

                # no content type provided or payload is json
                content_type = headers.get("Content-Type")
                if not content_type or re.search("json", content_type, re.IGNORECASE):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False,
                    )
                elif content_type == "application/x-www-form-urlencoded":
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False,
                    )
                elif content_type == "multipart/form-data":
                    # must del headers['Content-Type'], or the correct
                    # Content-Type generated by urllib3 will be overwritten.
                    del headers["Content-Type"]
                    if isinstance(post_params, Mapping):
                        pairs_iter: Iterable[tuple[str, object]] = post_params.items()
                    elif isinstance(post_params, Iterable) and not isinstance(
                        post_params, (str, bytes)
                    ):
                        pairs_iter = post_params
                    else:
                        raise ApiValueError(
                            "post_params must be a mapping or iterable of 2-item pairs",
                        )
                    fields: list[tuple[str, object]] = []
                    for pair in pairs_iter:
                        if isinstance(pair, (str, bytes)):
                            raise ApiValueError(
                                "Items in post_params must be 2-item iterables",
                            )
                        try:
                            key, value = pair
                        except Exception:  # noqa: BLE001
                            raise ApiValueError(
                                "Items in post_params must be 2-item iterables",
                            ) from None
                        if isinstance(value, Mapping) or (
                            isinstance(value, Iterable)
                            and not isinstance(value, (str, bytes))
                        ):
                            value = json.dumps(value)
                        fields.append((key, value))
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=fields,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False,
                    )
                # Pass a `string` parameter directly in the body to support
                # other content types than JSON when `body` argument is
                # provided in serialized form.
                elif isinstance(body, str) or isinstance(body, bytes):
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False,
                    )
                elif headers["Content-Type"].startswith("text/") and isinstance(
                    body, bool
                ):
                    request_body = "true" if body else "false"
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        preload_content=False,
                        timeout=timeout,
                        headers=headers,
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For `GET`, `HEAD`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False,
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
